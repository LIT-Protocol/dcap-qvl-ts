import { rawEcdsaSigToDer, verifyEcdsaSignature, verifyRsaSignature } from '../src/crypto-utils';
import forge from 'node-forge';
import fs from 'fs';
import path from 'path';
import { sha256 } from '@noble/hashes/sha256';

describe('crypto-utils', () => {
  describe('rawEcdsaSigToDer', () => {
    it('converts raw ECDSA signature to DER encoding (P-256)', () => {
      // Example r and s (32 bytes each)
      const r = new Uint8Array(32).fill(0x01);
      const s = new Uint8Array(32).fill(0x02);
      const rawSig = new Uint8Array([...r, ...s]);
      const der = rawEcdsaSigToDer(rawSig);
      // Decode with node-forge to check correctness
      const asn1 = forge.asn1.fromDer(forge.util.createBuffer(der));
      // Check that asn1 is a SEQUENCE with two INTEGER children
      expect(asn1.tagClass).toBe(forge.asn1.Class.UNIVERSAL);
      expect(asn1.type).toBe(forge.asn1.Type.SEQUENCE);
      expect(Array.isArray(asn1.value)).toBe(true);
      if (Array.isArray(asn1.value)) {
        expect(asn1.value).toHaveLength(2);
        const rDecoded = asn1.value[0].value;
        const sDecoded = asn1.value[1].value;
        if (typeof rDecoded === 'string' && typeof sDecoded === 'string') {
          expect(forge.util.bytesToHex(rDecoded)).toBe(
            forge.util.bytesToHex(forge.util.hexToBytes(Buffer.from(r).toString('hex'))),
          );
          expect(forge.util.bytesToHex(sDecoded)).toBe(
            forge.util.bytesToHex(forge.util.hexToBytes(Buffer.from(s).toString('hex'))),
          );
        } else {
          throw new Error('ASN.1 INTEGER value is not a string');
        }
      }
    });
  });

  describe('verifyEcdsaSignature', () => {
    it('verifies a valid ECDSA P-256 signature and fails on tampered signature (from generated vector)', () => {
      // Read test vector files generated by gen-ecdsa-test-vector.js
      const pubPem = fs.readFileSync(path.join(__dirname, 'ecdsa-pub.pem'), 'utf8');
      const message = fs.readFileSync(path.join(__dirname, 'ecdsa-message.txt'));
      const sigRawHex = fs.readFileSync(path.join(__dirname, 'ecdsa-sig-raw.hex'), 'utf8').trim();
      const sigRaw = Buffer.from(sigRawHex, 'hex');
      // Node.js crypto signs the hash, so hash the message before verifying with @noble/curves
      const msgHash = sha256(message);
      expect(
        verifyEcdsaSignature({
          publicKey: pubPem,
          message: msgHash,
          signature: sigRaw,
          isRaw: true,
        }),
      ).toBe(true);
      // Tampered signature (flip a byte)
      const tampered = Buffer.from(sigRaw);
      tampered[0] ^= 0xff;
      expect(
        verifyEcdsaSignature({
          publicKey: pubPem,
          message: msgHash,
          signature: tampered,
          isRaw: true,
        }),
      ).toBe(false);
    });
  });

  describe('verifyRsaSignature', () => {
    it('verifies a valid RSA PKCS#1 v1.5 signature and fails on tampered signature', () => {
      // Generate RSA keypair
      const keypair = forge.pki.rsa.generateKeyPair({ bits: 2048 });
      const message = 'hello world';
      const md = forge.md.sha256.create();
      md.update(message, 'utf8');
      const signature = keypair.privateKey.sign(md);
      const pubPem = forge.pki.publicKeyToPem(keypair.publicKey);
      const valid = verifyRsaSignature({
        publicKey: pubPem,
        message: Buffer.from(message, 'utf8'),
        signature: Buffer.from(signature, 'binary'),
        scheme: 'pkcs1',
        hashAlg: 'sha256',
      });
      expect(valid).toBe(true);
      // Tampered signature
      const tampered = Buffer.from(signature, 'binary');
      tampered[0] ^= 0xff;
      const invalid = verifyRsaSignature({
        publicKey: pubPem,
        message: Buffer.from(message, 'utf8'),
        signature: tampered,
        scheme: 'pkcs1',
        hashAlg: 'sha256',
      });
      expect(invalid).toBe(false);
    });
  });
});
