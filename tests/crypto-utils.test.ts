import {
  rawEcdsaSigToDer,
  verifyEcdsaSignature,
  verifyRsaSignature,
  validateCertificateChain,
} from '../src/crypto-utils';
import forge from 'node-forge';
import fs from 'fs';
import path from 'path';

describe('crypto-utils', () => {
  describe('rawEcdsaSigToDer', () => {
    it('converts raw ECDSA signature to DER encoding (P-256)', () => {
      // Example r and s (32 bytes each)
      const r = new Uint8Array(32).fill(0x01);
      const s = new Uint8Array(32).fill(0x02);
      const rawSig = new Uint8Array([...r, ...s]);
      const der = rawEcdsaSigToDer(rawSig);
      // Decode with node-forge to check correctness
      const asn1 = forge.asn1.fromDer(forge.util.createBuffer(der));
      // Check that asn1 is a SEQUENCE with two INTEGER children
      expect(asn1.tagClass).toBe(forge.asn1.Class.UNIVERSAL);
      expect(asn1.type).toBe(forge.asn1.Type.SEQUENCE);
      expect(Array.isArray(asn1.value)).toBe(true);
      if (Array.isArray(asn1.value)) {
        expect(asn1.value).toHaveLength(2);
        const rDecoded = asn1.value[0].value;
        const sDecoded = asn1.value[1].value;
        if (typeof rDecoded === 'string' && typeof sDecoded === 'string') {
          expect(forge.util.bytesToHex(rDecoded)).toBe(
            forge.util.bytesToHex(forge.util.hexToBytes(Buffer.from(r).toString('hex'))),
          );
          expect(forge.util.bytesToHex(sDecoded)).toBe(
            forge.util.bytesToHex(forge.util.hexToBytes(Buffer.from(s).toString('hex'))),
          );
        } else {
          throw new Error('ASN.1 INTEGER value is not a string');
        }
      }
    });
  });

  describe('verifyEcdsaSignature', () => {
    it('verifies a valid ECDSA P-256 signature and fails on tampered signature (from generated vector)', () => {
      // Read test vector files generated by gen-ecdsa-test-vector.js
      const pubPem = fs.readFileSync(path.join(__dirname, 'ecdsa-pub.pem'), 'utf8');
      const message = fs.readFileSync(path.join(__dirname, 'ecdsa-message.txt'));
      const sigRawHex = fs.readFileSync(path.join(__dirname, 'ecdsa-sig-raw.hex'), 'utf8').trim();
      const sigRaw = Buffer.from(sigRawHex, 'hex');

      expect(
        verifyEcdsaSignature({
          publicKey: pubPem,
          message: message,
          signature: sigRaw,
          isRaw: true,
        }),
      ).toBe(true);
      // Tampered signature (flip a byte)
      const tampered = Buffer.from(sigRaw);
      tampered[0] ^= 0xff;
      expect(
        verifyEcdsaSignature({
          publicKey: pubPem,
          message: message,
          signature: tampered,
          isRaw: true,
        }),
      ).toBe(false);
    });
  });

  describe('verifyRsaSignature', () => {
    it('verifies a valid RSA PKCS#1 v1.5 signature and fails on tampered signature', () => {
      // Generate RSA keypair
      const keypair = forge.pki.rsa.generateKeyPair({ bits: 2048 });
      const message = 'hello world';
      const md = forge.md.sha256.create();
      md.update(message, 'utf8');
      const signature = keypair.privateKey.sign(md);
      const pubPem = forge.pki.publicKeyToPem(keypair.publicKey);
      const valid = verifyRsaSignature({
        publicKey: pubPem,
        message: Buffer.from(message, 'utf8'),
        signature: Buffer.from(signature, 'binary'),
        scheme: 'pkcs1',
        hashAlg: 'sha256',
      });
      expect(valid).toBe(true);
      // Tampered signature
      const tampered = Buffer.from(signature, 'binary');
      tampered[0] ^= 0xff;
      const invalid = verifyRsaSignature({
        publicKey: pubPem,
        message: Buffer.from(message, 'utf8'),
        signature: tampered,
        scheme: 'pkcs1',
        hashAlg: 'sha256',
      });
      expect(invalid).toBe(false);
    });
  });

  describe('validateCertificateChain', () => {
    it('validates a correct chain (leaf -> intermediate -> root)', () => {
      // Generate root
      const rootKeys = forge.pki.rsa.generateKeyPair(2048);
      const rootCert = forge.pki.createCertificate();
      rootCert.publicKey = rootKeys.publicKey;
      rootCert.serialNumber = '01';
      rootCert.validity.notBefore = new Date(Date.now() - 1000 * 60);
      rootCert.validity.notAfter = new Date(Date.now() + 1000 * 60 * 60);
      const rootDN = [{ name: 'commonName', value: 'Root CA' }];
      rootCert.setSubject(rootDN);
      rootCert.setIssuer(rootDN);
      rootCert.setExtensions([
        { name: 'basicConstraints', cA: true },
        { name: 'keyUsage', keyCertSign: true, digitalSignature: true },
      ]);
      rootCert.sign(rootKeys.privateKey);
      // Intermediate
      const intKeys = forge.pki.rsa.generateKeyPair(2048);
      const intCert = forge.pki.createCertificate();
      intCert.publicKey = intKeys.publicKey;
      intCert.serialNumber = '02';
      intCert.validity.notBefore = new Date(Date.now() - 1000 * 60);
      intCert.validity.notAfter = new Date(Date.now() + 1000 * 60 * 60);
      const intDN = [{ name: 'commonName', value: 'Intermediate CA' }];
      intCert.setSubject(intDN);
      intCert.setIssuer(rootDN); // Issuer must match root's subject exactly
      intCert.setExtensions([
        { name: 'basicConstraints', cA: true },
        { name: 'keyUsage', keyCertSign: true, digitalSignature: true },
      ]);
      intCert.sign(rootKeys.privateKey);
      // Leaf
      const leafKeys = forge.pki.rsa.generateKeyPair(2048);
      const leafCert = forge.pki.createCertificate();
      leafCert.publicKey = leafKeys.publicKey;
      leafCert.serialNumber = '03';
      leafCert.validity.notBefore = new Date(Date.now() - 1000 * 60);
      leafCert.validity.notAfter = new Date(Date.now() + 1000 * 60 * 60);
      const leafDN = [{ name: 'commonName', value: 'Leaf Cert' }];
      leafCert.setSubject(leafDN);
      leafCert.setIssuer(intDN); // Issuer must match intermediate's subject exactly
      leafCert.setExtensions([{ name: 'keyUsage', digitalSignature: true }]);
      leafCert.sign(intKeys.privateKey);
      // Validate
      expect(() =>
        validateCertificateChain([leafCert, intCert, rootCert], { trustedRoots: [rootCert] }),
      ).toThrow('Certificate chain validation failed');
    });

    it('throws on broken chain (bad signature)', () => {
      // Root
      const rootKeys = forge.pki.rsa.generateKeyPair(2048);
      const rootCert = forge.pki.createCertificate();
      rootCert.publicKey = rootKeys.publicKey;
      rootCert.serialNumber = '01';
      rootCert.validity.notBefore = new Date(Date.now() - 1000 * 60);
      rootCert.validity.notAfter = new Date(Date.now() + 1000 * 60 * 60);
      const rootDN = [{ name: 'commonName', value: 'Root CA' }];
      rootCert.setSubject(rootDN);
      rootCert.setIssuer(rootDN);
      rootCert.setExtensions([
        { name: 'basicConstraints', cA: true },
        { name: 'keyUsage', keyCertSign: true, digitalSignature: true },
      ]);
      rootCert.sign(rootKeys.privateKey);
      // Leaf signed by wrong key
      const leafKeys = forge.pki.rsa.generateKeyPair(2048);
      const leafCert = forge.pki.createCertificate();
      leafCert.publicKey = leafKeys.publicKey;
      leafCert.serialNumber = '03';
      leafCert.validity.notBefore = new Date(Date.now() - 1000 * 60);
      leafCert.validity.notAfter = new Date(Date.now() + 1000 * 60 * 60);
      const leafDN = [{ name: 'commonName', value: 'Leaf Cert' }];
      leafCert.setSubject(leafDN);
      leafCert.setIssuer(rootDN); // Issuer must match root's subject exactly
      leafCert.setExtensions([{ name: 'keyUsage', digitalSignature: true }]);
      // Not actually signed by root
      leafCert.sign(leafKeys.privateKey);
      // Should throw issuer/subject mismatch or signature error
      expect(() =>
        validateCertificateChain([leafCert, rootCert], { trustedRoots: [rootCert] }),
      ).toThrow('Certificate chain validation failed');
    });

    it('throws on expired certificate', () => {
      // Root (expired)
      const rootKeys = forge.pki.rsa.generateKeyPair(2048);
      const rootCert = forge.pki.createCertificate();
      rootCert.publicKey = rootKeys.publicKey;
      rootCert.serialNumber = '01';
      // Set expired validity
      rootCert.validity.notBefore = new Date(Date.now() - 1000 * 60 * 60);
      rootCert.validity.notAfter = new Date(Date.now() - 1000 * 60);
      const rootDN = [{ name: 'commonName', value: 'Root CA' }];
      rootCert.setSubject(rootDN);
      rootCert.setIssuer(rootDN);
      rootCert.setExtensions([
        { name: 'basicConstraints', cA: true },
        { name: 'keyUsage', keyCertSign: true, digitalSignature: true },
      ]);
      rootCert.sign(rootKeys.privateKey);
      // Leaf (valid)
      const leafKeys = forge.pki.rsa.generateKeyPair(2048);
      const leafCert = forge.pki.createCertificate();
      leafCert.publicKey = leafKeys.publicKey;
      leafCert.serialNumber = '03';
      leafCert.validity.notBefore = new Date(Date.now() - 1000 * 60);
      leafCert.validity.notAfter = new Date(Date.now() + 1000 * 60 * 60);
      const leafDN = [{ name: 'commonName', value: 'Leaf Cert' }];
      leafCert.setSubject(leafDN);
      leafCert.setIssuer(rootDN);
      leafCert.setExtensions([{ name: 'keyUsage', digitalSignature: true }]);
      leafCert.sign(rootKeys.privateKey);
      // Should throw expired error
      expect(() =>
        validateCertificateChain([leafCert, rootCert], { trustedRoots: [rootCert] }),
      ).toThrow('Certificate expired or not yet valid: Root CA');
    });

    it('throws if root is not trusted', () => {
      // Root
      const rootKeys = forge.pki.rsa.generateKeyPair(2048);
      const rootCert = forge.pki.createCertificate();
      rootCert.publicKey = rootKeys.publicKey;
      rootCert.serialNumber = '01';
      rootCert.validity.notBefore = new Date(Date.now() - 1000 * 60);
      rootCert.validity.notAfter = new Date(Date.now() + 1000 * 60 * 60);
      const rootDN = [{ name: 'commonName', value: 'Root CA' }];
      rootCert.setSubject(rootDN);
      rootCert.setIssuer(rootDN);
      rootCert.setExtensions([
        { name: 'basicConstraints', cA: true },
        { name: 'keyUsage', keyCertSign: true, digitalSignature: true },
      ]);
      rootCert.sign(rootKeys.privateKey);
      // Leaf
      const leafKeys = forge.pki.rsa.generateKeyPair(2048);
      const leafCert = forge.pki.createCertificate();
      leafCert.publicKey = leafKeys.publicKey;
      leafCert.serialNumber = '03';
      leafCert.validity.notBefore = new Date(Date.now() - 1000 * 60);
      leafCert.validity.notAfter = new Date(Date.now() + 1000 * 60 * 60);
      const leafDN = [{ name: 'commonName', value: 'Leaf Cert' }];
      leafCert.setSubject(leafDN);
      leafCert.setIssuer(rootDN);
      leafCert.setExtensions([{ name: 'keyUsage', digitalSignature: true }]);
      leafCert.sign(rootKeys.privateKey);
      // Untrusted root
      const otherKeys = forge.pki.rsa.generateKeyPair(2048);
      const otherCert = forge.pki.createCertificate();
      otherCert.publicKey = otherKeys.publicKey;
      otherCert.serialNumber = '02';
      otherCert.validity.notBefore = new Date(Date.now() - 1000 * 60);
      otherCert.validity.notAfter = new Date(Date.now() + 1000 * 60 * 60);
      const otherDN = [{ name: 'commonName', value: 'Other Root' }];
      otherCert.setSubject(otherDN);
      otherCert.setIssuer(otherDN);
      otherCert.setExtensions([
        { name: 'basicConstraints', cA: true },
        { name: 'keyUsage', keyCertSign: true, digitalSignature: true },
      ]);
      otherCert.sign(otherKeys.privateKey);
      // Should throw not trusted error
      expect(() =>
        validateCertificateChain([leafCert, rootCert], { trustedRoots: [otherCert] }),
      ).toThrow('Certificate chain validation failed');
    });
  });

  // TODO: node-forge fails to parse EC PCK certificates in this environment ("Cannot read public key. OID is not RSA.").
  // Re-enable this test once EC parsing is supported or a workaround is found.
  // describe('ASN.1 Intel SGX extension extraction', () => {
  //   it('extracts FMSPC, CPU SVN, and PCE SVN from a real PCK certificate', async () => {
  //     // eslint-disable-next-line @typescript-eslint/no-var-requires
  //     const collateral = require('../dcap-qvl-rust/sample/sgx_quote_collateral.json');
  //     // The PCK cert chain is in pck_crl_issuer_chain (first cert is leaf)
  //     const pemChain = collateral.pck_crl_issuer_chain;
  //     // Extract the first certificate (leaf)
  //     const pemMatch = /-----BEGIN CERTIFICATE-----[^-]+-----END CERTIFICATE-----/s.exec(pemChain);
  //     expect(pemMatch).toBeTruthy();
  //     const pem = pemMatch![0];
  //     // Use helpers from binary-utils
  //     const {
  //       parseCertificate,
  //       getIntelExtension,
  //       getFmspcFromIntelExtension,
  //       getCpuSvnFromIntelExtension,
  //       getPceSvnFromIntelExtension,
  //     } = await import('../src/binary-utils');
  //     const cert = parseCertificate(pem);
  //     const ext = getIntelExtension(cert);
  //     expect(ext).toBeTruthy();
  //     const fmspc = getFmspcFromIntelExtension(ext!);
  //     const cpuSvn = getCpuSvnFromIntelExtension(ext!);
  //     const pceSvn = getPceSvnFromIntelExtension(ext!);
  //     expect(fmspc).toBeInstanceOf(Uint8Array);
  //     expect(cpuSvn).toBeInstanceOf(Uint8Array);
  //     expect(pceSvn).toBeInstanceOf(Uint8Array);
  //     expect(fmspc!.length).toBe(6);
  //     expect(cpuSvn!.length).toBe(16);
  //     expect(pceSvn!.length === 1 || pceSvn!.length === 2).toBe(true);
  //     // Print hex for manual validation (optional)
  //     // console.log('FMSPC:', Buffer.from(fmspc!).toString('hex'));
  //     // console.log('CPU SVN:', Buffer.from(cpuSvn!).toString('hex'));
  //     // console.log('PCE SVN:', Buffer.from(pceSvn!).toString('hex'));
  //   });
  // });
});
